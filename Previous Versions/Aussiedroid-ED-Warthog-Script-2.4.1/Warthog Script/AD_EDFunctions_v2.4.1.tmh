//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// MACRO VARIABLE INITALISATION //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int mRequestDock, mShowGameStats, mJumpPrevSubSys, mJumpNextSubSys, mSignalLights, mSignalLightsLong, mFastModeSwitch;
	int mPowerEngSys, mPowerEngWep, mPowerSysWep, mPowerSysEng, mPowerWepSys, mPowerWepEng, mSplitPowerEng, mSplitPowerSys, mSplitPowerWep, mPowerTank, mPowerOffensive;
	int mThrottleFwdOnly, mThrottleFullScale, mThrottlePrecision, mThrottleTrimmed, mThrottleFullScaleCustom;
	int mTextHostileAttack, mTextHostileMock, mTextHostileDemand, mTextHostileScanning, mTextPassiveHail, mTextPassiveFarewell, mTextPassiveHonk, mTextPassiveSurrender;
	int mTextCLEARChatBox, mTextFriendlyThanks, mTextFriendlyFollow, mTextFriendlyOfferAid, mTextFriendlyDeter, mTextBasicHello, mTextBasicHonk, mTextBasicQuery, mTextBasicAttack;

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// HARDWARE MAPPINGS //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int initSetJoystickCurves() {																// Autopilot Select Switch position sets joystick curve profile
		int profile = 1;																		// Three different presets are selectable on the fly
		if (Throttle[APPAT]) profile = 0;
		if (Throttle[APALT]) profile = 2;
			SetSCurve(&Joystick, JOYX, 0, JS_DEADZONE, 0, JS_CURVE[profile], JS_ZOOM[profile]);
			SetSCurve(&Joystick, JOYY, 0, JS_DEADZONE, 0, JS_CURVE[profile], JS_ZOOM[profile]);
		printf("Joystick Profile[%d]: Curve=%d, Zoom=%d\x0a", profile, JS_CURVE[profile], JS_ZOOM[profile]);
	}
																								// FLAP position sets Throttle Curve profile
	int initSetThrottleCurves() {																// Three different presets are selectable on the fly
		mThrottleFwdOnly = EXEC(  																// Initialising Throttle Forward Only Preset (SRV etc)
								"TrimDXAxis(DX_Z_AXIS, SET(-1024));"							// *TrimDXAxis(axis, +/-1024) trim is additive, SET forces trim value, CURRENT reads axis.pos
								"if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, -100, 0, 0);" 	// *SetSCurve(&Device, axis, left_deadzone%, center_deadzone%, right_deadzone%, curve(-20...20), scale)
								"if(CruiseOnThrottle == 1) SetSCurve(&Throttle, THR_RIGHT, 0, -90, 0, 0);"		// Trims Axis 10% when Supercruise On Throttle Active
								"printf(\"Throttle Profile: FORWARD ONLY [0 -> 100]\\x0a\");"
								"SetThrottle();"); 												
		mThrottleFullScale = EXEC(  															// Make Throttle Linear & Full Scale	(Default: Full Range)	
								"TrimDXAxis(DX_Z_AXIS, SET(0));"								// Initialising Throttle Full Scale Preset 
								"if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, 5, 0, 0);"		// ..(Alternative= "SetJCurve(&Throttle, THR_RIGHT, 50, 50);")
								"if(CruiseOnThrottle == 1) SetJCurve(&Throttle, THR_RIGHT, 90, 100);"			// Trims Axis 10% when Supercruise On Throttle Active
								"printf(\"Throttle Profile: FULL SCALE [-100 -> 100]\\x0a\");"
								"SetThrottle();");												// *SetJCurve(&device, axis, physical axis value%, DirectX output value%)
		mThrottlePrecision = EXEC( 																// Initialising Throttle Precision Preset (Docking etc)
								"TrimDXAxis(DX_Z_AXIS, SET(0));" 								// Allows Throttle Movement ONLY to the middle of blue zone
								"SetSCurve(&Throttle, THR_RIGHT, 0, 2, 0, 2, -2);"
								"printf(\"Throttle Profile: PRECISION [-50 -> 50]\\x0a\");"
								"SetThrottle();");
		mThrottleTrimmed = EXEC(  																// Initialising Throttle Trimmed 25% @ Beginning/End Preset (ALTERNATIVE)
								"TrimDXAxis(DX_Z_AXIS, SET(0));" 								// <Unmapped>
								"SetSCurve(&Throttle, THR_RIGHT, -25, 0, -25, 0);"
								"printf(\"Throttle Profile: TRIMMED [-75 -> 75]\\x0a\");"
								"SetThrottle();");
		mThrottleFullScaleCustom = EXEC(  														// Initialising Throttle Full Scale - Max Shorter @ 80% Preset (ALTERNATIVE)
								"TrimDXAxis(DX_Z_AXIS, SET(0));" 								// Slightly Shorter Fwd travel distance for my RSeat RS1 Cockpit. :)
								"SetJCurve(&Throttle, THR_RIGHT, 80, 100);"						// <Unmapped>
								"printf(\"Throttle Profile: FULL SCALE CUSTOM [-100 -> 80]\\x0a\");"
								"SetThrottle();");
	}

	int initJoystickAxis() { 																	// Set Default Joystick Axis
		MapAxis(&Joystick, JOYX, DX_X_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);
			SetSCurve(&Joystick, JOYX, 0, 0, 0, 0, 0);
		MapAxis(&Joystick, JOYY, DX_Y_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);
			SetSCurve(&Joystick, JOYY, 0, 0, 0, 0, 0);
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
		printf("Initialising Joystick Axis ... ");
	}

	int initThrottleAxis() { 																	// Set Default Throttle Axis
		MapAxis(&Throttle, THR_RIGHT, DX_Z_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);					// Set Right Throttle
			SetJCurve(&Throttle, THR_RIGHT, 50, 50);
		MapAxis(&Throttle, THR_LEFT, DX_ZROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);					// Set Left Throttle
			SetSCurve(&Throttle, THR_LEFT, 0, 0, 0, 0, 0);
		MapAxis(&Throttle, SCX, DX_XROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);						// Set Slew Control X Axis
			SetSCurve(&Throttle, SCX, 0, 20, 0, 2, -1);
		MapAxis(&Throttle, SCY, DX_YROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);						// Set Slew Control Y Axis
			SetSCurve(&Throttle, SCY, 0, 20, 0, 2, -1);
		MapAxis(&Throttle, THR_FC, DX_SLIDER_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);					// Set Friction Control Axis Curve (Sensor Range Zoom Scaling) 
			if(CustomDXSliderCurve == 0) SetSCurve(&Throttle, THR_FC, 0, 0, 0, 0, 0);									// (Default)
			if(CustomDXSliderCurve == 1) SetCustomCurve(&Throttle, THR_FC, LIST(0,0, 33,25, 66,50, 80,75, 100,100)); 	// (OPTIONAL OVERRIDE) (Linear Recommended in ED) *LIST(Axis physical position, Axis output Value)
		printf("Initialising Throttle Axis\x0a");
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
	}
	
	int SetThrottle() {																			// Prevents Throttle jumping around on mode changes
		DXAxis(DX_Z_AXIS, -AxisVal(Throttle[THR_RIGHT], &axdata)); }

	int initTFRPRudder() {																		// Initialise Thrustmaster Rudder Pedal Axes (When enabled in AD_EDSettings)
		MapAxis(&TFRPRudder, TRUDDER,  DX_Z_AXIS, AXIS_NORMAL,   MAP_ABSOLUTE);					// *UNTESTED*
		MapAxis(&TFRPRudder, TRPLEFT,  DX_X_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
		MapAxis(&TFRPRudder, TRPRIGHT, DX_Y_AXIS, AXIS_REVERSED, MAP_ABSOLUTE); }
	
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// CUSTOM MACROS //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
																								// MACROS Include a series of automated key presses to perform a specific task.

	int initCustomCommands() {																	// MACRO: Auto-Docking Request
		mRequestDock = CHAIN(  
			LOCK+PULSE+TargetPanel, D(),
			PULSE+UINextPanel, D(),																// Limitation: This will only work correctly if Target Panel cursor in 
			PULSE+UINextPanel, D(),																//			   default/orig position, else will be misaligned.
			PULSE+UISelect, D(),
			PULSE+UIDown, D(),
			PULSE+UISelect, D(),
			PULSE+UIPrevPanel, D(),
			PULSE+UIPrevPanel, D(),
			PULSE+UIBack, LOCK);

		mShowGameStats = CHAIN(																	// MACRO: Display the combined OSD FPS & Bandwidth meters
			PULSE+ShowFramerate, D(150),
			PULSE+ShowConnectionStatus);

		mFastModeSwitch = CHAIN(																// MACRO: Automated Game Mode Switching
			LOCK+PULSE+UIEscape, D(700),														// From Cockpit, it will navigate the Game Menu to put you back at the Game Mode selection screen automatically!
			PULSE+UIUp, D(400),
			PULSE+UIUp, D(400),
			PULSE+UISelect, D(500),
			PULSE+UIRight, D(250),
			PULSE+UISelect, D(6000),															// ** Depending on the load times of your PC, this value may need to be changed/increased (6000ms is default)
			PULSE+UIDown, D(500),
			PULSE+UISelect, LOCK);

	    mSignalLights = CHAIN(																	// MACRO: Flash Ship/SRV Lights (Standard)
	    	DOWN+ShipLights, D(800),															// Will turn lights on & off 3 times @ short intervals
	    	UP+ShipLights, D(600),
	    	DOWN+ShipLights, D(1000),
	    	UP+ShipLights, D(700),
	    	DOWN+ShipLights, D(1000),
	    	UP+ShipLights);
	    	
	    mSignalLightsLong = CHAIN(																// MACRO: Flash Ship/SRV Lights (Long)
	    	DOWN+ShipLights, D(800),															// Will turn lights on & off 6 times @ short intervals
	    	UP+ShipLights, D(600),
	    	DOWN+ShipLights, D(1000),
	    	UP+ShipLights, D(700),
	    	DOWN+ShipLights, D(1000),
	    	UP+ShipLights, D(750),
	    	DOWN+ShipLights, D(1300),
	    	UP+ShipLights, D(800),
	    	DOWN+ShipLights, D(1000),
	    	UP+ShipLights, D(650),
	    	DOWN+ShipLights, D(1000),
	    	UP+ShipLights);

		mJumpPrevSubSys = CHAIN(																// MACRO: Select Previous Subsystem x6 (Targets Powerplant, or close to it)
			PULSE+SelectPrevSubsystem, D(),														// HOLD down Previous Subsystem button to activate
			PULSE+SelectPrevSubsystem, D(),														// <Unmapped>
			PULSE+SelectPrevSubsystem, D(),
			PULSE+SelectPrevSubsystem, D(),
			PULSE+SelectPrevSubsystem, D(),
			PULSE+SelectPrevSubsystem);

		mJumpNextSubSys = CHAIN(																// MACRO: Select Next Subsystem x5 (Targets ??, or close to it)
			PULSE+SelectNextSubsystem, D(),														// HOLD down Next Subsystem button to activate
			PULSE+SelectNextSubsystem, D(),														// <Unmapped>
			PULSE+SelectNextSubsystem, D(),
			PULSE+SelectNextSubsystem, D(),
			PULSE+SelectNextSubsystem);

		mPowerEngSys = CHAIN(																	// MACRO: Advanced PIP Management: 4xENG, 2xSYS
			PULSE+BalancePower, D(),															// HOLD down PIP to Engines button to activate
			PULSE+PowerEng, D(),
			PULSE+PowerSys, D(),
			PULSE+PowerEng, D(),
			PULSE+PowerEng);

		mPowerEngWep = CHAIN(																	// MACRO: Advanced PIP Management: 4xENG, 2xWEP
			PULSE+BalancePower, D(),															// LONG HOLD down PIP to Engines button to activate 
			PULSE+PowerEng, D(),
			PULSE+PowerWep, D(),
			PULSE+PowerEng, D(),
			PULSE+PowerEng);
			
		mPowerSysWep = CHAIN(																	// MACRO: Advanced PIP Management: 4xSYS, 2xWEP
			PULSE+BalancePower, D(),															// LONG HOLD down PIP to System button to activate
			PULSE+PowerSys, D(),
			PULSE+PowerWep, D(),
			PULSE+PowerSys, D(),
			PULSE+PowerSys);

		mPowerSysEng = CHAIN(																	// MACRO: Advanced PIP Management: 4xSYS, 2xENG
			PULSE+BalancePower, D(),															// HOLD down PIP to System button to activate
			PULSE+PowerSys, D(),
			PULSE+PowerEng, D(),
			PULSE+PowerSys, D(),
			PULSE+PowerSys);

		mPowerWepSys = CHAIN(																	// MACRO: Advanced PIP Management: 4xWEP, 2xSYS
			PULSE+BalancePower, D(),															// LONG HOLD down PIP to Weapon button to activate
			PULSE+PowerWep, D(),
			PULSE+PowerSys, D(),
			PULSE+PowerWep, D(),
			PULSE+PowerWep);

		mPowerWepEng = CHAIN(																	// MACRO: Advanced PIP Management: 4xWEP, 2xENG
			PULSE+BalancePower, D(),															// HOLD down PIP to Weapon button to activate
			PULSE+PowerWep, D(),
			PULSE+PowerEng, D(),
			PULSE+PowerWep, D(),
			PULSE+PowerWep);			

		mSplitPowerEng = CHAIN(																	// MACRO: PIP ALTERNATIVE: 4xENG, 1xSYS, 1xWEP
			PULSE+BalancePower, D(), 															
			PULSE+PowerEng, D(), 
			PULSE+PowerEng);

		mSplitPowerSys = CHAIN(																	// MACRO: PIP ALTERNATIVE: 4xSYS, 1xENG, 1xWEP
			PULSE+BalancePower, D(), 															
			PULSE+PowerSys, D(), 
			PULSE+PowerSys);

		mSplitPowerWep = CHAIN(																	// MACRO: PIP ALTERNATIVE: 4xWEP, 1xSYS, 1xENG
			PULSE+BalancePower, D(), 															
			PULSE+PowerWep, D(), 
			PULSE+PowerWep);

		mPowerTank = CHAIN(																		// MACRO: PIP ALTERNATIVE: 3xWEP, 3xSYS
			PULSE+BalancePower, D(),															// HOLD down Balance PIPs button to activate
			PULSE+PowerWep, D(),
			PULSE+PowerSys, D(),
			PULSE+PowerWep, D(),
			PULSE+PowerWep, D(),
			PULSE+PowerSys);

		mPowerOffensive = CHAIN(																// MACRO: PIP ALTERNATIVE: 3xWEP, 3xENG 
			PULSE+BalancePower, D(),															// LONG HOLD down Balance PIPs button to activate
			PULSE+PowerEng, D(),
			PULSE+PowerWep, D(),
			PULSE+PowerEng, D(),
			PULSE+PowerEng, D(),
			PULSE+PowerWep);
	}

																								// TEXT CHAT MACROS:
																								// Tip: For Capitals = D(50), For Standard Chars = D(15),
	int initCustomTextCommands() {																//		For Double Letters & Spaces = D()
		mTextCLEARChatBox = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// SPECIAL: Clears any Text in the Chat Box. (Uses '/clear' command)
						           		PULSE+'\/', D(), PULSE+'c', D(15), PULSE+'l', D(15), PULSE+'e',D(15), PULSE+'a', D(15), PULSE+'r', D(15),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextHostileAttack = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// You're a disgrace! Die! Time to see the Rebuy!
						           		PULSE+'Y', D(50), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+'\'',D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+' ', D(),
										PULSE+'a', D(15), PULSE+' ', D()  , PULSE+'d', D(15), PULSE+'i', D(15), PULSE+'s', D(15), PULSE+'g', D(15), PULSE+'r', D(15), PULSE+'a', D(15), PULSE+'c', D(15), PULSE+'e', D(15), PULSE+'!', D(15), PULSE+' ', D(),					           
						           		PULSE+'D', D(50), PULSE+'i', D(15), PULSE+'e', D(15), PULSE+'!', D(15), PULSE+' ', D(15),
						           		PULSE+'T', D(50), PULSE+'i', D(15), PULSE+'m', D(15), PULSE+'e', D(15), PULSE+' ', D()  , PULSE+'t', D(15), PULSE+'o', D(15), PULSE+' ', D(),
										PULSE+'s', D(15), PULSE+'e', D()  , PULSE+'e', D(15), PULSE+' ', D()  , PULSE+'t', D(15), PULSE+'h', D(15), PULSE+'e', D(15), PULSE+' ', D(),
										PULSE+'R', D(50), PULSE+'e', D(15), PULSE+'b', D(15), PULSE+'u', D(15), PULSE+'y', D(15), PULSE+'!', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextHostileMock = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// I fart in your general direction :/
						           		PULSE+'I', D(50), PULSE+' ', D()  , PULSE+'f', D(15), PULSE+'a', D(15), PULSE+'r', D(15), PULSE+'t', D(15), PULSE+' ', D(),
						           		PULSE+'i', D(15), PULSE+'n', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+'r', D(15), PULSE+' ', D(),
						           		PULSE+'g', D(15), PULSE+'e', D(15), PULSE+'n', D(15), PULSE+'e', D(15), PULSE+'r', D(15), PULSE+'a', D(15), PULSE+'l', D(15), PULSE+' ', D(),
						           		PULSE+'d', D(15), PULSE+'i', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+'c', D(15), PULSE+'t', D(15), PULSE+'i', D(15), PULSE+'o', D(15), PULSE+'n', D(15), PULSE+' ', D(), PULSE+'\:', D(),  PULSE+'\/', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);		
		mTextHostileDemand = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// How much cargo is your life worth? Hand it over!
						           		PULSE+'H', D(50), PULSE+'o', D(15), PULSE+'w', D(15), PULSE+' ', D()  , PULSE+'m', D(15), PULSE+'u', D(15), PULSE+'c', D(15), PULSE+'h', D(15), PULSE+' ', D(),
										PULSE+'c', D(15), PULSE+'a', D(15), PULSE+'r', D(15), PULSE+'g', D(15), PULSE+'o', D(15), PULSE+' ', D(15), PULSE+'i', D(15), PULSE+'s', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+'r', D(15), PULSE+' ', D(),					           
						           		PULSE+'l', D(15), PULSE+'i', D(15), PULSE+'f', D(15), PULSE+'e', D(15), PULSE+' ', D()  , PULSE+'w', D(15), PULSE+'o', D(15), PULSE+'r', D(15), PULSE+'t', D(15), PULSE+'h', D(15), PULSE+'?', D(15), PULSE+' ', D(),
										PULSE+'H', D(50), PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'d', D(15), PULSE+' ', D()  , PULSE+'i', D(15), PULSE+'t', D(15), PULSE+' ', D(),
										PULSE+'o', D(15), PULSE+'v', D(15), PULSE+'e', D(15), PULSE+'r', D(15), PULSE+'!', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextHostileScanning = CHAIN(	UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Stay calm, cut your engines and prepare to be scanned. Move and you will be fired upon.
						           		PULSE+'S', D(50), PULSE+'t', D(15), PULSE+'a', D(15), PULSE+'y', D(15), PULSE+' ', D()  , PULSE+'c', D(15), PULSE+'a', D(15), PULSE+'l', D(15), PULSE+'m', D(15), PULSE+',', D(15), PULSE+' ', D(),
										PULSE+'c', D(15), PULSE+'u', D(15), PULSE+'t', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+'r', D(15), PULSE+' ', D()  , PULSE+'e', D(15), PULSE+'n', D(15), PULSE+'g', D(15), PULSE+'i', D(15), PULSE+'n', D(15), PULSE+'e', D(15), PULSE+'s', D(15), PULSE+' ', D(),				           
						           		PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'d', D(15), PULSE+' ', D()  , PULSE+'p', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+'p', D(15), PULSE+'a', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+' ', D(),
						           		PULSE+'t', D(15), PULSE+'o', D(15), PULSE+' ', D()  , PULSE+'b', D(15), PULSE+'e', D(15), PULSE+' ', D()  , PULSE+'s', D(15), PULSE+'c', D(15), PULSE+'a', D(15), PULSE+'n', D()  , PULSE+'n', D(15), PULSE+'e', D(15), PULSE+'d', D(15), PULSE+'.', D(15), PULSE+' ', D(),
							           	PULSE+'M', D(50), PULSE+'o', D(15), PULSE+'v', D(15), PULSE+'e', D(15), PULSE+' ', D()  , PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'d', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+' ', D(),
						           		PULSE+'w', D(15), PULSE+'i', D(15), PULSE+'l', D()  , PULSE+'l', D(15), PULSE+' ', D()  , PULSE+'b', D(15), PULSE+'e', D(15), PULSE+' ', D()  , PULSE+'f', D(15), PULSE+'i', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+'d', D(15), PULSE+' ', D(),
										PULSE+'u', D(15), PULSE+'p', D(15), PULSE+'o', D(15), PULSE+'n', D(15), PULSE+'.', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);

		mTextPassiveHail = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Greetings CMDR o7
						           		PULSE+'G', D(50), PULSE+'r', D(15), PULSE+'e', D()  , PULSE+'e', D(15), PULSE+'t', D(15), PULSE+'i', D(15), PULSE+'n', D(15), PULSE+'g', D(15), PULSE+'s', D(15), PULSE+' ', D(),
						           		PULSE+'C', D(50), PULSE+'M', D(50), PULSE+'D', D(50), PULSE+'R', D(50), PULSE+' ', D()  , PULSE+'o', D(15), PULSE+'7', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextPassiveFarewell = CHAIN(	UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Fly safe CMDR
						           		PULSE+'F', D(50), PULSE+'l', D(15), PULSE+'y', D(15), PULSE+' ', D()  , PULSE+'s', D(15), PULSE+'a', D(15), PULSE+'f', D(15), PULSE+'e', D(15), PULSE+' ', D(),
						           		PULSE+'C', D(50), PULSE+'M', D(50), PULSE+'D', D(50), PULSE+'R', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextPassiveHonk = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Easy there! Watch where you are going CMDR
						           		PULSE+'E', D(50), PULSE+'a', D(15), PULSE+'s', D(15), PULSE+'y', D(15), PULSE+' ', D()  , PULSE+'t', D(15), PULSE+'h', D(15), PULSE+'e', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+'!', D(15), PULSE+' ', D(),
						           		PULSE+'W', D(50), PULSE+'a', D(15), PULSE+'t', D(15), PULSE+'c', D(15), PULSE+'h', D(15), PULSE+' ', D()  , PULSE+'w', D(15), PULSE+'h', D(15), PULSE+'e', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+' ', D(),
						           		PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+' ', D()  , PULSE+'a', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+' ', D(),
						           		PULSE+'g', D(15), PULSE+'o', D(15), PULSE+'i', D(15), PULSE+'n', D(15), PULSE+'g', D(15), PULSE+' ', D()  , PULSE+'C', D(50), PULSE+'M', D(50), PULSE+'D', D(50), PULSE+'R', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);	
		mTextPassiveSurrender = CHAIN(	UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Hold your Fire! I surrender, what are your demands?
						           		PULSE+'H', D(50), PULSE+'o', D(15), PULSE+'l', D(15), PULSE+'d', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+'r', D(15), PULSE+' ', D()  , PULSE+'F', D(50), PULSE+'i', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+'!', D(15), PULSE+' ', D(),
						           		PULSE+'I', D(50), PULSE+' ', D()  , PULSE+'s', D(15), PULSE+'u', D(15), PULSE+'r', D()  , PULSE+'r', D(15), PULSE+'e', D(15), PULSE+'n', D(15), PULSE+'d', D(15), PULSE+'e', D(15), PULSE+'r', D(15), PULSE+',', D(15), PULSE+' ', D(),
						           		PULSE+'w', D(15), PULSE+'h', D(15), PULSE+'a', D(15), PULSE+'t', D(15), PULSE+' ', D()  , PULSE+'a', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+' ', D(),
						           		PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+'r', D(15), PULSE+' ', D()  , PULSE+'d', D(15), PULSE+'e', D(15), PULSE+'m', D(15), PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'d', D(15), PULSE+'s', D(15), PULSE+'?', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
				
		mTextFriendlyThanks = CHAIN(	UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Thank you for your assistance! o7
						           		PULSE+'T', D(50), PULSE+'h', D(15), PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'k', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+' ', D(),
						           		PULSE+'f', D(15), PULSE+'o', D(15), PULSE+'r', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+'r', D(15), PULSE+' ', D(),
						           		PULSE+'a', D(15), PULSE+'s', D()  , PULSE+'s', D(15), PULSE+'i', D(15), PULSE+'s', D(15), PULSE+'t', D(15), PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'c', D(15), PULSE+'e', D(15), PULSE+'!', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextFriendlyFollow = CHAIN(	UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Follow Me
						           		PULSE+'F', D(50), PULSE+'o', D(15), PULSE+'l', D()  , PULSE+'l', D(15), PULSE+'o', D(15), PULSE+'w', D(15), PULSE+' ', D()  , PULSE+'m', D(15), PULSE+'e', D(15), PULSE+' ', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);		
		mTextFriendlyOfferAid = CHAIN(	UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Can I help CMDR?
						           		PULSE+'C', D(50), PULSE+'a', D(15), PULSE+'n', D(15), PULSE+' ', D()  , PULSE+'I', D(50), PULSE+' ', D()  , PULSE+'h', D(15), PULSE+'e', D(15), PULSE+'l', D(15), PULSE+'p', D(15), PULSE+' ', D()  , PULSE+'C', D(50), PULSE+'M', D(50), PULSE+'D', D(50), PULSE+'R', D(50), PULSE+'?', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextFriendlyDeter = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// I don't want conflict, but I will protect what is mine
						           		PULSE+'I', D(50), PULSE+' ', D()  , PULSE+'d', D(15), PULSE+'o', D(15), PULSE+'n', D(15), PULSE+'\'',D(50), PULSE+'t', D(15), PULSE+' ', D()  , PULSE+'w', D(15), PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'t', D(15), PULSE+' ', D(),
						           		PULSE+'c', D(15), PULSE+'o', D(15), PULSE+'n', D(15), PULSE+'f', D(15), PULSE+'l', D(15), PULSE+'i', D(15), PULSE+'c', D(15), PULSE+'t', D(15), PULSE+',', D(15), PULSE+' ', D()  , PULSE+'b', D(15), PULSE+'u', D(15), PULSE+'t', D(15), PULSE+' ', D(),
						           		PULSE+'I', D(50), PULSE+' ', D()  , PULSE+'w', D(15), PULSE+'i', D(15), PULSE+'l', D()  , PULSE+'l', D(15), PULSE+' ', D()  , PULSE+'p', D(15), PULSE+'r', D(15), PULSE+'o', D(15), PULSE+'t', D(15), PULSE+'e', D(15), PULSE+'c', D(15), PULSE+'t', D(15), PULSE+' ', D(),
						           		PULSE+'w', D(15), PULSE+'h', D(15), PULSE+'a', D(15), PULSE+'t', D(15), PULSE+' ', D()  , PULSE+'i', D(15), PULSE+'s', D(15), PULSE+' ', D()  , PULSE+'m', D(15), PULSE+'i', D(15), PULSE+'n', D(15), PULSE+'e', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
										
		mTextBasicHello = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// CMDR! o7
						           		PULSE+'C', D(50), PULSE+'M', D(50), PULSE+'D', D(50), PULSE+'R', D(50), PULSE+'!', D(15), PULSE+' ', D()  , PULSE+'o', D(15), PULSE+'7', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextBasicHonk = CHAIN(			UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Easy there! Watch where you are going CMDR
						           		PULSE+'E', D(50), PULSE+'a', D(15), PULSE+'s', D(15), PULSE+'y', D(15), PULSE+' ', D()  , PULSE+'t', D(15), PULSE+'h', D(15), PULSE+'e', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+'!', D(15), PULSE+' ', D(),
						           		PULSE+'W', D(50), PULSE+'a', D(15), PULSE+'t', D(15), PULSE+'c', D(15), PULSE+'h', D(15), PULSE+' ', D()  , PULSE+'w', D(15), PULSE+'h', D(15), PULSE+'e', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+' ', D(),
						           		PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+' ', D()  , PULSE+'a', D(15), PULSE+'r', D(15), PULSE+'e', D(15), PULSE+' ', D(),
						           		PULSE+'g', D(15), PULSE+'o', D(15), PULSE+'i', D(15), PULSE+'n', D(15), PULSE+'g', D(15), PULSE+' ', D()  , PULSE+'C', D(50), PULSE+'M', D(50), PULSE+'D', D(50), PULSE+'R', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);		
		mTextBasicQuery = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// What do you want CMDR?
						           		PULSE+'W', D(50), PULSE+'h', D(15), PULSE+'a', D(15), PULSE+'t', D(15), PULSE+' ', D()  , PULSE+'d', D(15), PULSE+'o', D(15), PULSE+' ', D()  , PULSE+'y', D(15), PULSE+'o', D(15), PULSE+'u', D(15), PULSE+' ', D()  , PULSE+'w', D(14), PULSE+'a', D(15), PULSE+'n', D(15), PULSE+'t', D(15), PULSE+' ', D(),
										PULSE+'C', D(50), PULSE+'M', D(50), PULSE+'D', D(50), PULSE+'R', D(50), PULSE+'?', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
		mTextBasicAttack = CHAIN(		UIBack, D(), PULSE+CommsPanel, D(250), PULSE+QuickCommsPanel, D(),	// Let's Rock!!
						           		PULSE+'L', D(50), PULSE+'e', D(15), PULSE+'t', D(15), PULSE+'\'',D(15), PULSE+'s', D(15), PULSE+' ', D()  , PULSE+'R', D(50), PULSE+'o', D(15), PULSE+'c', D(15), PULSE+'k', D(15), PULSE+'!', D(15), PULSE+'!', D(15), PULSE+' ', D(),
										PULSE+QuickCommsPanel, D(), UIEscape, D(250), UIEscape);
	}


	int initEscapeVector() {																	// MACRO: Disengage Defensively + Emergency Escape Vector (Hold Pinky Trigger)
		if(!StartupLock) {																		//  This line is only required to prevent running on startup
			printf("EVASIVE MANEUVERS! Emergency Escape Vector Calculating...\x0a");
			ActKey(KEYON+mPowerSysEng);															// Set PIPs to SYSx4 ENGx2 - Defensive Getaway
			if(AutoChaffOnEscape) DeferCall(500,  &ActKey, KEYON+PULSE+FireChaffLauncher);		// Optional: Auto-fire Chaff to cover your escape
			if(CargoSc) {		  DeferCall(750,  &ActKey, KEYON+PULSE+CargoScoop);				// Override: Cargo Scoop (will force close scoop, overriding toggle)
								  DeferCall(750,  &ActKey, KEYON+PULSE+EXEC("CargoSc = 0;"));
								  DeferCall(750,  &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4)); }	// set LED 4 OFF (Override)					  
			if(Gears) {			  DeferCall(1000, &ActKey, KEYON+PULSE+LandingGear);			// Override: Landing Gear (will force retract gears, overriding toggle)
								  DeferCall(1000, &ActKey, KEYON+PULSE+EXEC("Gears   = 0;"));
								  DeferCall(1000, &ActKey, KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED5)); }	// set LED 5 OFF (Override)
			if(AutoBoostOnEscape) DeferCall(1250, &ActKey, KEYON+PULSE+EngineBoost);			// Optional: Auto-fire Boost to help evade
			if(HPoints) {		  DeferCall(1500, &ActKey, KEYON+PULSE+DeployHardpoints);		// If Hardpoints are deployed, retract, ready for jump
								  DeferCall(1500, &ActKey, KEYON+PULSE+EXEC("HPoints = 0;")); }	// Update Hardpoint variable value to retracted (0)
			DeferCall(1750, &ActKey, KEYON+PULSE+FrameShiftDrive); }							// After Retracting Hardpoints etc, Engage FSD (or High Wake if another System is selected route)
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// CUSTOM FUNCTIONS //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
																								// FUNCTIONS Include logic to customise specific Button/Toggle functionality.

	int initHardpointManagement() {																// FUNCTION: Manage Hardpoint Deployment & Associated Menu Mappings
		if(Joystick[S4])	if(!Joystick[H4P]) {												// This check forces Hardpoints to be deployed so Escape Vector is always in the right state. 
			if(!HPoints) {																		// (It will result in the hardpoints appearing to deploy in your HUD, but does not slow macro down)
				HPoints = 1;
				ActKey(KEYON+PULSE+DeployHardpoints); }
			initEscapeVector();	}																// Disengage & Escape Vector Macro														
		if(Joystick[H4P])	if(!Joystick[S4]) {
			ActKey(KEYON+PULSE+UIEscape); }														// EXIT to MENU (Hold Modifier 2)
		if(Joystick[H4P])	if(Joystick[S4]) {
			ActKey(KEYON+PULSE+mFastModeSwitch); }												// EXIT to MENU + Fast Game Mode Switch (Hold Modifier 1+2)
		if(!Joystick[H4P])	if(!Joystick[S4]) {													// Standard Hardpoint Deploy/Retract
			if(!StartupLock) {
				ActKey(KEYON+PULSE+DeployHardpoints);											// If in Ship: Deploy/Retract Hardpoints
				HPoints=!HPoints;				
				ActKey(KEYON+DOWN+ShowCQCScoreboard); }	}										// If in CQC: Show Scoreboard (Hold)
	}


	int initSetCombinedFire(int toggleValue) { 													// FUNCTION: Calculate Combined Fire Status
		if(toggleValue) {																		// When disabled, Trigger 2 is independant on Pinky Button (DX3) only
			combinePriSecFire = !combinePriSecFire;	}
		if(combinePriSecFire){
			printf("Trigger 2: Set to COMBINED Primary + Secondary Fire\x0a");
			MapKey(&Joystick, TG2, CHAIN(PrimaryFire, SecondaryFire)); } 
		else {
			printf("Trigger 2: Set to SEPARATE Fire\x0a");
			MapKey(&Joystick, TG2, 0); }
	}


	int initAdvancedFireModule() {																// FUNCTION: Advanced Weapon Fire Module
		if(Joystick[TG1]) {																		//	[Integrates Combo Fire & Repeater Fire into Primary/Secondary Fire Buttons]
			if(Joystick[S4]) {																	
				rAutoP=!rAutoP;
				if(!rFireP) {
					ActKey(KEYON+DOWN+PrimaryFire);												// Pinky Trigger + Primary = REPEATING FIRE
					rFireP = 1; }	
				if(rAutoP) {
					printf("Repeater Fire: AUTO ON  (PRIMARY) ^^\x0a"); } }
			if(Joystick[H4P]) {
				initSetCombinedFire(1);	}														// CMS Hat Switch + Primary = COMBINE TOGGLE
			if(!Joystick[H4P]) if(!Joystick[S4]) {
				rAutoP = 0;
				if(!rFireP) {
					ActKey(KEYON+DOWN+PrimaryFire); } } }										// Primary Only = STANDARD FIRE (Releases Repeating Fire when on Manual User Preference)	
		if(!Joystick[TG1]) {																	// 	[Set 'RepeaterAutoRelease' value in the User Preferences]
			if(RepeaterAutoRelease) {															// Auto Primary Release ENABLED
				if(rFireP) if(rAutoP) {
					DeferCall(RepeaterTimer, 	&ActKey, KEYON+UP+PrimaryFire); 				// Automatic timer delay to release Primary Fire after a 6 second hold
					DeferCall(RepeaterTimerOff, &ActKey, KEYON+PULSE+EXEC("rFireP = 0;"));		// Slight offset timing of +200ms to ensure triggering after event
					DeferCall(RepeaterTimerOff, &ActKey, KEYON+PULSE+EXEC("rAutoP = 0;"));
					DeferCall(RepeaterTimer, 	&ActKey, KEYON+PULSE+EXEC("printf(\"Repeater Fire: AUTO OFF (PRIMARY)\\x0a\");")); }
				if(!rFireP) {
					ActKey(KEYON+UP+PrimaryFire); }	}
			if(!RepeaterAutoRelease) {															// Manual Primary Release ENABLED
				if(!rFireP) if(!rAutoP) {														// Checks if Repeater Fire was enabled, if NO, only release primary fire button
					ActKey(KEYON+UP+PrimaryFire); }
				if(rFireP) if(!rAutoP) {														// Checks if Repeater Fire was enabled, if YES, also reset flag & print
					ActKey(KEYON+UP+PrimaryFire);
					rFireP = 0;
					printf("Repeater Fire: AUTO OFF (PRIMARY)\x0a"); } } }
		if(Joystick[S3]) {
			if(Joystick[S4]) {
				rAutoS=!rAutoS;
				if(!rFireS) {
					ActKey(KEYON+DOWN+SecondaryFire);											// Pinky Trigger + Secondary = REPEATING FIRE
					rFireS = 1; }
				if(rAutoS) {
					printf("Repeater Fire: AUTO ON  (SECONDARY) ^^\x0a"); } }
			if(!Joystick[S4]) {
				rAutoS = 0;
				if(!rFireS) {
					ActKey(KEYON+DOWN+SecondaryFire); } } }										// Secondary Only = STANDARD FIRE (Releases Repeating Fire)
		if(!Joystick[S3]) {
			if(RepeaterAutoRelease) {															// Auto Secondary Release ENABLED
				if(rFireS) if(rAutoS) {
					DeferCall(RepeaterTimer, 	&ActKey, KEYON+UP+SecondaryFire); 				// Automatic timer delay to release Secondary Fire after a 6 second hold
					DeferCall(RepeaterTimerOff, &ActKey, KEYON+PULSE+EXEC("rFireS = 0;"));		// Slight offset timing of +200ms to ensure triggering after event
					DeferCall(RepeaterTimerOff, &ActKey, KEYON+PULSE+EXEC("rAutoS = 0;"));
					DeferCall(RepeaterTimer, 	&ActKey, KEYON+PULSE+EXEC("printf(\"Repeater Fire: AUTO OFF (SECONDARY)\\x0a\");")); }
				if(!rFireS) {
					ActKey(KEYON+UP+SecondaryFire); } }				
			if(!RepeaterAutoRelease) {															// Manual Secondary Release ENABLED
				if(!rFireS) if(!rAutoS) {														// Checks if Repeater Fire was enabled, if NO, only release secondary fire button
					ActKey(KEYON+UP+SecondaryFire); }
				if(rFireS) if(!rAutoS) {														// Checks if Repeater Fire was enabled, if YES, also reset flag & print
					ActKey(KEYON+UP+SecondaryFire);
					rFireS = 0;
					printf("Repeater Fire: AUTO OFF (SECONDARY)\x0a"); } } }	
	}

																								// FUNCTION: Advanced PIP Selection based on User Preference
	int initAdvancedPIPManagement() {															//                 [NOTE: Set UserPIPPref in the AD_EDSettings file]
		if(UserPIPPref == 1) {																	// STANDARD SINGLE-TIER PIPS [Elite Dangerous Default Functionality]
			if(Joystick[H3U]) ActKey(KEYON+PULSE+PowerEng);												// [Power to Engines (1 PIP)]
			if(Joystick[H3D]) ActKey(KEYON+PULSE+BalancePower);											// [Balance Power (1 PIP)]
			if(Joystick[H3L]) ActKey(KEYON+PULSE+PowerSys);												// [Power to Systems (1 PIP)]
			if(Joystick[H3R]) ActKey(KEYON+PULSE+PowerWep);	}											// [Power to Weapons (1 PIP)]
		if(UserPIPPref == 2) {																	// DOUBLE-TIER PIPS       [Inc. short & long press, no modifier]
//			if(Joystick[H3U]) MapKey(&Joystick, H3U, TEMPO(PowerEng, mSplitPowerEng, PIPPressDelay));	// [Short: 1xENG, 		 Long: 4xENG 1xSYS 1xWEP] [*ALT*]
//			if(Joystick[H3D]) MapKey(&Joystick, H3D, TEMPO(BalancePower, mPowerTank, PIPPressDelay));	// [Short: Balance,		 Long: 3xSYS 3xWEP] 	  [*ALT*]
//			if(Joystick[H3L]) MapKey(&Joystick, H3L, TEMPO(PowerSys, mSplitPowerSys, PIPPressDelay));	// [Short: 1xSYS, 		 Long: 4xSYS 1xENG 1xWEP] [*ALT*]
//			if(Joystick[H3R]) MapKey(&Joystick, H3R, TEMPO(PowerWep, mSplitPowerWep, PIPPressDelay));	// [Short: 1xWEP, 		 Long: 4xWEP 1xENG 1xSYS] [*ALT*]
			if(Joystick[H3U]) MapKey(&Joystick, H3U, TEMPO(PowerEng, mPowerEngSys, PIPPressDelay));		// [Short: 1xENG, 		 Long: 4xENG 2xSYS]
			if(Joystick[H3D]) MapKey(&Joystick, H3D, TEMPO(BalancePower, mPowerTank, PIPPressDelay));	// [Short: Balance,		 Long: 3xSYS 3xWEP]
			if(Joystick[H3L]) MapKey(&Joystick, H3L, TEMPO(PowerSys, mPowerSysWep, PIPPressDelay));		// [Short: 1xSYS, 		 Long: 4xSYS 2xWEP]
			if(Joystick[H3R]) MapKey(&Joystick, H3R, TEMPO(PowerWep, mPowerWepSys, PIPPressDelay));	}	// [Short: 1xWEP, 		 Long: 4xWEP 2xSYS]
		if(UserPIPPref == 3) {																	// TRIPLE-TIER PIPS       [Inc. short/long/very long presses, no modifier]
			if(Joystick[H3U]) MapKey(&Joystick, H3U, TEMPO(PowerEng, TEMPO(mPowerEngSys, mPowerEngWep, PIPPressDelay), PIPPressDelay));			// [Short: 1xENG, 	 Med: 4xENG 2xSYS, 	Long: 4xENG 2xWEP]
			if(Joystick[H3D]) MapKey(&Joystick, H3D, TEMPO(BalancePower, TEMPO(mPowerTank, mPowerOffensive, PIPPressDelay), PIPPressDelay));	// [Short: Balance,  Med: 3xSYS 3xWEP,  Long: 3xENG, 3xWEP]
			if(Joystick[H3L]) MapKey(&Joystick, H3L, TEMPO(PowerSys, TEMPO(mPowerSysEng, mPowerSysWep, PIPPressDelay), PIPPressDelay));			// [Short: 1xSYS, 	 Med: 4xSYS 2xENG,  Long: 4xSYS 2xWEP]
			if(Joystick[H3R]) MapKey(&Joystick, H3R, TEMPO(PowerWep, TEMPO(mPowerWepEng, mPowerWepSys, PIPPressDelay), PIPPressDelay));	}		// [Short: 1xWEP, 	 Med: 4xWEP 2xENG,  Long: 4xWEP 2xSYS]
	}
																								// FUNCTION: Predefined Text Chat Comms Panel Responses
																								//           [NOTE: Set ChatPresetMode in the AD_EDSettings file]
	int initTextChatPresets() {																	// 3 Chat Preset Groups can be selected on-the-fly via Pinkly Throttle Switch
		if(ChatPreset == 0) {																	// If Pinky Toggle is CENTER
			if(ChatPresetMode == 0) {															// If Basic Chat Preset selected in AD_EDSettings.tmh, choose Basic Text Responses
				if(Joystick[H1U]) ActKey(KEYON+PULSE+mTextBasicHello);
				if(Joystick[H1D]) ActKey(KEYON+PULSE+mTextBasicQuery);
				if(Joystick[H1L]) ActKey(KEYON+PULSE+mTextBasicHonk);
				if(Joystick[H1R]) ActKey(KEYON+PULSE+mTextBasicAttack);	}
			if(ChatPresetMode == 1) {															// If Advanced Chat Preset selected in AD_EDSettings.tmh, choose Advanced Text Responses
				if(Joystick[H1U]) ActKey(KEYON+PULSE+mTextPassiveHail);
				if(Joystick[H1D]) ActKey(KEYON+PULSE+mTextPassiveFarewell);
				if(Joystick[H1L]) ActKey(KEYON+PULSE+mTextPassiveHonk);
				if(Joystick[H1R]) ActKey(KEYON+PULSE+mTextPassiveSurrender); } }
		if(ChatPreset == 1) {																	// If Pinky Toggle is UP
			if(Joystick[H1U]) ActKey(KEYON+PULSE+mTextHostileAttack);
			if(Joystick[H1D]) ActKey(KEYON+PULSE+mTextHostileMock);
			if(Joystick[H1L]) ActKey(KEYON+PULSE+mTextHostileDemand);
			if(Joystick[H1R]) ActKey(KEYON+PULSE+mTextHostileScanning); }
		if(ChatPreset == 2) {																	// If Pinky Toggle is DOWN
			if(Joystick[H1U]) ActKey(KEYON+PULSE+mTextFriendlyFollow);
			if(Joystick[H1D]) ActKey(KEYON+PULSE+mTextFriendlyThanks);
			if(Joystick[H1L]) ActKey(KEYON+PULSE+mTextFriendlyOfferAid);
			if(Joystick[H1R]) ActKey(KEYON+PULSE+mTextFriendlyDeter); }
	}

																								// TOGGLE functions ensure Warthog toggle switch keeps correct positioning.
	int initToggleCamera(){																		// TOGGLE: External 'Debug' Camera	
		if(Throttle[EFLNORM]){																	// Default: OFF
			if(!inCameraMode) {																	// <Unmapped>
				printf("Camera Suite: ON\x0a");
				inCameraMode = 1;
				ActKey(KEYON+PULSE+ClassifiedCamera);
				DeferCall(200, &ActKey, KEYON+PULSE+SPC); } }									// Automatically bypasses the pop-up window on entry (Default:200ms) :)
		if(!Throttle[EFLNORM]){
			if(inCameraMode) {
				printf("Camera Suite: OFF\x0a");
				inCameraMode = 0;
				ActKey(KEYON+PULSE+ClassifiedCamera); } }
	}


	int initEnhancedFAOFF() {																	// FUNCTION: Enhanced Joystick Curves tailored for Flight Assist Off (TOGGLE)
		if(Throttle[SPDF]) {																	//    AKA     "FAOFF LIKE A BOSS!"
			if(Joystick[S4]) {																	// FA OFF: TOGGLE
				ActKey(KEYON+PULSE+AlternativeFlightMode);										// Enables Alternative Flight Control Mappings (when using the Pinky Trigger).
				AltFlightToggle = 1; }
			if(!Joystick[S4]) {
				ActKey(KEYON+PULSE+FlightAssist);
				SetSCurve(&Joystick, JOYX, 0, 1, 0, 2, -1);										// Reduces the Joystick sensitivity on Forward TOGGLE on FA Off
				SetSCurve(&Joystick, JOYY, 0, 1, 0, 2, -1);										// Full Joystick sensitivity remains on Back HOLD on FA Off for quick turns in combat
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED1));				// set LED 1 OFF
				FAOFFToggle = 1;
				printf("FA-Off Joystick Profile [2]: Curve=2, Zoom=-1\x0a"); } }
		if(!Throttle[SPDF]) {
			if(AltFlightToggle) {
				ActKey(KEYON+PULSE+AlternativeFlightMode);										// Disables Alternative Flight Control Mappings (works with both Pinky Trigger & Without!).
				AltFlightToggle=!AltFlightToggle; }
			if(FAOFFToggle) {
				ActKey(KEYON+PULSE+FlightAssist);
				SetSCurve(&Joystick, JOYX, 0, 1, 0, 1, 0);										// Return Joystick Curve back to default settings when disabling forward toggle
				SetSCurve(&Joystick, JOYY, 0, 1, 0, 1, 0);										// 		Limitation: If you had your Joystick Curve set to UP/DOWN when enabling FA OFF,
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED1));				// set LED 1 ON     you will need to toggle back to center, then UP/DOWN again to reapply settings.
				FAOFFToggle=!FAOFFToggle;
				printf("FA-Off Joystick Profile [1]: Curve=1, Zoom=0\x0a"); } }
		if(Throttle[SPDB]) {																	// FA OFF: HOLD
			if(Joystick[S4]) {
				ActKey(KEYON+PULSE+AlternativeFlightMode);
				AltFlightHold = 1; }
			if(!Joystick[S4]) {
				ActKey(KEYON+PULSE+FlightAssist);			
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED1));				// set LED 1 OFF
				FAOFFHold = 1; } }
		if(!Throttle[SPDB]) {		
			if(AltFlightHold) {
				ActKey(KEYON+PULSE+AlternativeFlightMode);										// Disables Alternative Flight Control Mappings (works with both Pinky Trigger & Without!).
				AltFlightHold=!AltFlightHold; }		
			if(FAOFFHold) {
				ActKey(KEYON+PULSE+FlightAssist);		
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED1));				// set LED 1 ON
				FAOFFHold=!FAOFFHold; } }
	}


	int initToggleRotationCorrection() {														// TOGGLE: Rotational Correction	
		if(Throttle[EORMOTOR]){																	// Default: ON (Position toggle switch DOWN to disable)
			if(!RCorrection) {																	// Press 'F4' to toggle manually if misaligned, or change in Sys Panel.
				printf("Rotation Correction: DISABLED !!\x0a");
				RCorrection = 1;
				ActKey(KEYON+PULSE+RotationalCorrection);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED2)); } }			// set LED 2 OFF
		if(!Throttle[EORMOTOR]){
			if(RCorrection) {
				printf("Rotation Correction: ENABLED  ^^\x0a");
				RCorrection = 0;
				if(!StartupLock) {
					ActKey(KEYON+PULSE+RotationalCorrection); }
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED2)); } }			// set LED 2 ON
	}


	int initToggleSilentRunning() {																// TOGGLE: Silent Running	
		if(Throttle[APUON]){																	// Default: OFF (Exhaust Vents Open)
			if(!SRunning) {																		// Press 'DEL' to toggle manually if misaligned, or change in Sys Panel.
				if(!Joystick[S4]) {
					ActKey(KEYON+PULSE+SilentRunning);											// [Toggle Hold]
					printf("Silent Running: ACTIVATED   !!\x0a"); }
				if(Joystick[S4])  {																// Heat Sink + Silent Running Combo [Pinky+Silent Running]
					ActKey(KEYON+PULSE+DeployHeatSink);
					ActKey(KEYON+PULSE+SilentRunning);
					printf("Silent Running: COOL RUNNINGS (Heat Sink Combo Sequence Activated!)\x0a"); }
				SRunning = 1;
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED3)); } }			// set LED 3 ON
		if(!Throttle[APUON]){
			if(SRunning) {
				ActKey(KEYON+PULSE+SilentRunning);												// [Toggle Release]
				printf("Silent Running: DEACTIVATED <<\x0a");
				SRunning = 0;
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED3)); } }			// set LED 3 OFF
	}


	int initToggleCargoScoop() {																// TOGGLE: Cargo Scoop	
		if(Throttle[RDRNRM]){																	// Default: OFF (Scoop Closed)
			if(!CargoSc) {																		// Press 'HOME' to toggle manually if required.
				printf("Cargo Scoop: DEPLOYED >>\x0a");
				CargoSc = 1;
				ActKey(KEYON+PULSE+CargoScoop);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED4));				// set LED 4 ON
				if(CargoPrecisionMode) {
					TrimDXAxis(DX_Z_AXIS, SET(0));
					SetSCurve(&Throttle, THR_RIGHT, 0, 2, 0, 2, -2);
					printf("Throttle Profile: CARGO SCOOP OVERRIDE PRECISION [-50 -> 50]\x0a");
					SetThrottle(); } } }
		if(!Throttle[RDRNRM]){
			if(CargoSc) {
				CargoSc = 0;
				if(!Joystick[S4]) if(!Joystick[H4P]) {
					ActKey(KEYON+PULSE+CargoScoop);
					printf("Cargo Scoop: RETRACTED <<\x0a");
					if(CargoPrecisionMode) {
						if(CargoReturnMode == 0) {
							TrimDXAxis(DX_Z_AXIS, SET(-1024));
							if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, -100, 0, 0);
							if(CruiseOnThrottle == 1) SetSCurve(&Throttle, THR_RIGHT, 0, -90, 0, 0); 
							printf("Throttle Profile: CARGO SCOOP REVERT FORWARD ONLY [0 -> 100]\x0a"); }
						if(CargoReturnMode == 1) {
							TrimDXAxis(DX_Z_AXIS, SET(0));
							if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, 5, 0, 0);
							if(CruiseOnThrottle == 1) SetJCurve(&Throttle, THR_RIGHT, 90, 100);
							printf("Throttle Profile: CARGO SCOOP REVERT FULL SCALE [-100 -> 100]\x0a"); }							
						if(CargoReturnMode == 2) {
							TrimDXAxis(DX_Z_AXIS, SET(0));
							SetJCurve(&Throttle, THR_RIGHT, 80, 100);
							printf("Throttle Profile: CARGO SCOOP REVERT FULL SCALE CUSTOM [-100 -> 80]\x0a"); }
						if(CargoReturnMode == 3) {
							TrimDXAxis(DX_Z_AXIS, SET(0));
							SetSCurve(&Throttle, THR_RIGHT, -25, 0, -25, 0);
							printf("Throttle Profile: CARGO SCOOP REVERT TRIMMED [-75 -> 75]\x0a"); }							
						SetThrottle(); } }
				if(Joystick[S4])  if(Joystick[H4P]) {
					ActKey(KEYON+PULSE+JettisonAllCargo);
					printf("Cargo Scoop: JETTISON ALL CARGO !!\x0a");
					if(CargoPrecisionMode) {
						if(CargoReturnMode == 0) {
							TrimDXAxis(DX_Z_AXIS, SET(-1024));
							if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, -100, 0, 0);
							if(CruiseOnThrottle == 1) SetSCurve(&Throttle, THR_RIGHT, 0, -90, 0, 0); 
							printf("Throttle Profile: CARGO SCOOP REVERT FORWARD ONLY [0 -> 100]\x0a"); }
						if(CargoReturnMode == 1) {
							TrimDXAxis(DX_Z_AXIS, SET(0));
							if(CruiseOnThrottle == 0) SetSCurve(&Throttle, THR_RIGHT, 0, 5, 0, 0);
							if(CruiseOnThrottle == 1) SetJCurve(&Throttle, THR_RIGHT, 90, 100);
							printf("Throttle Profile: CARGO SCOOP REVERT FULL SCALE [-100 -> 100]\x0a"); }							
						if(CargoReturnMode == 2) {
							TrimDXAxis(DX_Z_AXIS, SET(0));
							SetJCurve(&Throttle, THR_RIGHT, 80, 100);
							printf("Throttle Profile: CARGO SCOOP REVERT FULL SCALE CUSTOM [-100 -> 80]\x0a"); }
						if(CargoReturnMode == 3) {
							TrimDXAxis(DX_Z_AXIS, SET(0));
							SetSCurve(&Throttle, THR_RIGHT, -25, 0, -25, 0);
							printf("Throttle Profile: CARGO SCOOP REVERT TRIMMED [-75 -> 75]\x0a"); }							
						SetThrottle(); }
					DeferCall(5000, &ActKey, KEYON+PULSE+CargoScoop);
					DeferCall(5050, &ActKey, KEYON+PULSE+EXEC("printf(\"Cargo Scoop: RETRACTED <<\\x0a\");")); }
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED4)); } }			// set LED 4 OFF
	}


	int initToggleLandingGear() {																// TOGGLE: Landing Gear	
		if(Throttle[EACON]){																	// Default: ON (Assumes you are docked when loading into ED) 
			if(!Gears) {																		// Press 'L' to toggle manually if starting in space, or change in Sys Panel.
				printf("Landing Gear: DEPLOYED >>\x0a");
				Gears = 1;
				ActKey(KEYON+PULSE+LandingGear);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT+LED5)); } }			// set LED 5 ON
		if(!Throttle[EACON]){
			if(Gears) {
				printf("Landing Gear: RETRACTED <<\x0a");
				Gears = 0;
				ActKey(KEYON+PULSE+LandingGear);
				ActKey(KEYON+PULSE+LED(&Throttle, LED_ONOFF, LED_CURRENT-LED5)); } }			// set LED 5 OFF
	}


	int initToggleShipLights(int toggleValue) { 												// FUNCTION: Calculate ShipLights state.
		if(toggleValue) {																		// Dims Throttle LED Backlight intensity when active.
			Lights=!Lights; }																	// Note: This can get a little buggy with the SRV multiple lighting levels.
		if(Lights){																				// Press 'INSERT' to toggle manually if SRV has messed things up or extra long hold to reset.
			printf("Lights: ^^ ILLUMINATE! ^^\x0a");
			ActKey(KEYON+PULSE+ShipLights);
			ActKey(ShipLights);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_INTENSITY, 50)); }							// Dim Throttle Lights
		if(!Lights) {
			printf("Lights:    DELUMINATE!\x0a");
			ActKey(KEYON+PULSE+ShipLights);
			ActKey(ShipLights);
			ActKey(KEYON+PULSE+LED(&Throttle, LED_INTENSITY, 172)); } 							// Return Throttle Lights to Default
	}


	int initDockNLightsEnhancer() {
		if(Joystick[S4]) {
			ActKey(KEYON+PULSE+mRequestDock);									 				// [Short+Pinky: Auto-Dock Request]
			printf("Attempting Auto-Dock Procedure...\x0a"); }
		if(!Joystick[S4]) {
			if(LightSeqShort) {
				ActKey(KEYON+PULSE+mSignalLights);												// [Short: Short Signal Light Sequence]
				printf("Lights: ^ SHORT SIGNAL SEQUENCE ACTIVATED ^\x0a");
				LightSeqShort=!LightSeqShort; }
			if(LightSeqLong) {
				ActKey(KEYON+PULSE+mSignalLightsLong);											// [Long: Long Signal Light Sequence]
				printf("Lights: ^ LONG SIGNAL SEQUENCE ACTIVATED ^\x0a");
				LightSeqLong=!LightSeqLong; } } 	
	}


	int initIDLEMaster() {																		// FUNCTION: Enforce Throttle IDLE (Stationary) on any Throttle Mode
		if(!StartupLock) {
			if(Throttle[IDLELON]) {
				if(!Throttle[FLAPU]) {															// Resets Throttle Axis to 0 for Full Range Throttle Modes
					DXAxis(DX_ZROT_AXIS, 0);													// Prevents issues launching from stations etc
					DXAxis(DX_Z_AXIS, 0);
					LockAxis(&Throttle, THR_LEFT, 1);											// Lock Axes to keep null value
					LockAxis(&Throttle, THR_RIGHT, 1);
					ActKey(KEYON+PULSE+SRVHandbrake); }											// IDLE Doubles as SRV Handbrake ON when on surface
				if(Throttle[FLAPU]) {															// Resets Throttle Axis to 0 for Forward Only Throttle Mode
					DXAxis(DX_ZROT_AXIS, 32767);
					DXAxis(DX_Z_AXIS, 32767);
					LockAxis(&Throttle, THR_LEFT, 1);											// Lock Axes to keep null value
					LockAxis(&Throttle, THR_RIGHT, 1);
					ActKey(KEYON+PULSE+SRVHandbrake); } }										// IDLE Doubles as SRV Handbrake ON when on surface
			if(!Throttle[IDLELON]) {
				LockAxis(&Throttle, THR_LEFT, 0);												// Unlocks the Throttle Axes when exiting IDLE
				LockAxis(&Throttle, THR_RIGHT, 0);
				ActKey(KEYON+PULSE+SRVHandbrake); } }											// Release the SRV Handbrake
	}


	int initHeadlookModeSelect() {																// FUNCTION: Choose Headlook Center Method, based on hardware preference
		if(!StartupLock) {		
			if(HeadtrackPref == 0) {															// 			(Maps to the Engine Operate Ign/Norm LEFT UP)
				if(!Joystick[S4]) ActKey(KEYON+PULSE+LookCenter);								// [Short:		 Headlook Center Toggle] 	[MOUSE]
				if(Joystick[S4])  ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); }				// [Short+Pinky: VA Toggle]
			if(HeadtrackPref == 1) {
				if(!Joystick[S4]) ActKey(KEYON+PULSE+TrackIRCenter);							// [Short: 		 TIR Center]				[TRACKIR/TOBI EYE/EDTRACKER]
				if(Joystick[S4])  ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); }				// [Short+Pinky: VA Toggle]
			if(HeadtrackPref == 2) {
				if(!Joystick[S4]) ActKey(KEYON+PULSE+ResetHeadOrientation);						// [Short: 		 Reset HMD Orientation]		[VR/VIVE/OCCULUS RIFT]
				if(Joystick[S4])  ActKey(KEYON+PULSE+ToggleVoiceAttackGlobal); } }				// [Short+Pinky: VA Toggle]			
	}


	int initMicCommander() {																	// FUNCTION: Manages Microphone Internal/External Push-to-Talk buttons
		if(Throttle[MSP]) {																		// [HOLD PTT]
			if(Throttle[EFROVER]) ActKey(KEYON+DOWN+InternalVoiceCommsPTT);						// If Mic Toggle OFF: Use Internal PTT Voice Comms Open Comms
			if(Throttle[EFRNORM]) ActKey(KEYON+DOWN+ExternalVoiceCommsPTT); 					// If Mic Toggle ON:  Use External PTT Voice Comms Open Comms
			MicCheckHold = 1; }
		if(!Throttle[MSP]) if(MicCheckHold) {													// [HOLD PTT]
			ActKey(KEYON+UP+InternalVoiceCommsPTT);												// Release PTT Buttons
			ActKey(KEYON+UP+ExternalVoiceCommsPTT); 
			MicCheckHold=!MicCheckHold; }
		if(Throttle[EOLMOTOR]) {																// [TOGGLE PTT]
			if(Throttle[EFROVER]) printf("Voice Comms: ^^  INTERNAL MIC OPEN  ^^\x0a");
			if(Throttle[EFROVER]) ActKey(KEYON+DOWN+InternalVoiceCommsPTT);						// If Mic Toggle OFF: Use Internal PTT Voice Comms Open Comms
			if(Throttle[EFRNORM]) printf("Voice Comms: ^^  EXTERNAL MIC OPEN  ^^\x0a");
			if(Throttle[EFRNORM]) ActKey(KEYON+DOWN+ExternalVoiceCommsPTT); 					// If Mic Toggle ON:  Use External PTT Voice Comms Open Comms
			MicCheckToggle = 1; }
		if(!Throttle[EOLMOTOR]) if(MicCheckToggle) {											// [TOGGLE PTT]
			if(Throttle[EFROVER]) printf("Voice Comms: << INTERNAL MIC CLOSED <<\x0a");
			if(Throttle[EFRNORM]) printf("Voice Comms: << EXTERNAL MIC CLOSED <<\x0a");
			ActKey(KEYON+UP+InternalVoiceCommsPTT);												// Release PTT Buttons
			ActKey(KEYON+UP+ExternalVoiceCommsPTT);	
			MicCheckToggle=!MicCheckToggle; }
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
// REPORT SCRIPT STATES //
//--------------------------------------------------------------------------------------------------------------------------------------------------------------//

	int initPrintState(){																		// Display the status of the macro toggles & user prefs on run. (Optimised for TARGET GUI)
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
		printf("ENHANCEMENTS LOADING: v%d.%d.%d TARGET Macros & Functions initialising!\x0a", ADVersionMajor, ADVersionMinor, ADVersionPoint);
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
		printf("USER PREFERENCES: 		Supercruise on Throttle	= %d	PIP Preset		= %d \x0a", CruiseOnThrottle, UserPIPPref);		
		printf("Text Chat Preset Mode	= %d	MFD Active		= %d	Chaff on Escape		= %d \x0a", ChatPresetMode, UseMFD, AutoChaffOnEscape);
		printf("LED Backlight Level	= %d	Custom Slider Curve	= %d	Boost on Escape		= %d \x0a", SetLED, CustomDXSliderCurve, AutoBoostOnEscape);	
		printf("				Headtrack Center Mode	= %d	AUTO Repeater Fire	= %d \x0a", HeadtrackPref, RepeaterAutoRelease);
		printf("\x0a");
		printf("DEFAULT TOGGLE STATE:   	(Set Your Throttle Toggles!)\x0a");
		printf("Combine Pri+Sec Fire	= %d	Rotational Correction 	= %d	Cargo Scoop		= %d\x0a", combinePriSecFire, RCorrection, CargoSc);
		printf("Landing Gear		= %d	Classified Camera Mode	= %d	Ship Lights		= %d\x0a", Gears, inCameraMode, Lights);
		printf("-----------------------------------------------------------------------------------------------------------------------------------------------\x0a");
		printf("Starting Macros... Throttle Profile Preset: NOT DEFINED      		(Toggle FLAPS Before You Fly!)\x0a"); // Don't Stress! This is just a reminder to toggle the Throttle Presets toggle ONCE before starting ED.
	}

//--------------------------------------------------------------------------------------------------------------------------------------------------------------//
